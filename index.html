<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>@avatarkage/automod</title>
<link rel="icon" href="https://automod.avatarkage.com/logo.png" type="image/png" />
<meta property="og:title" content="@avatarkage/automod" />
<meta property="og:description" content="AutoMod API for external apps. Created by AvatarKage and released under MIT license." />
<meta property="og:image" content="https://us-east-1.tixte.net/uploads/cdn.avatarka.ge/automod_banner_png.png" />
<meta property="og:url" content="https://automod.avatarkage.com" />
<meta property="og:type" content="website" />
<meta itemprop="name" content="@avatarkage/automod" />
<meta itemprop="description" content="AutoMod API for external apps. Created by AvatarKage and released under MIT license." />
<meta itemprop="image" content="https://us-east-1.tixte.net/uploads/cdn.avatarka.ge/automod_banner_png.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="@avatarkage/automod" />
<meta name="twitter:description" content="AutoMod API for external apps. Created by AvatarKage and released under MIT license." />
<meta name="twitter:image" content="https://us-east-1.tixte.net/uploads/cdn.avatarka.ge/automod_banner_png.png" />
<meta name="twitter:url" content="https://automod.avatarkage.com" />
<meta name="theme-color" content="#4c58e6" />
<meta name="author" content="AvatarKage" />

<style>
    @font-face {
        font-family: 'Rethink Sans';
        src: url('rethink_sans.ttf');
    }
    body {
        display: flex;
        background: #080808;
        height: 100vh;
        overflow: hidden;
        color: #eaeaea;
        font-family: Rethink Sans, sans-serif;
        font-size: 14px;
        justify-content: center;
        align-items: center;
        scale: 1;
    }
    .scale-wrapper {
        transform: scale(1.1);
        transform-origin: center;
    }
    hr {
        border-top: 1px solid #272727;
        border-radius: 8px;
        margin: 16px 0px;
        background-color: transparent;
    }
    .vr {
        display: inline-block;
        border-left: 1px solid #272727;
        border-radius: 8px;
        width: 1px;
        margin-right: 8px;
        align-self: stretch;
        background-color: transparent;
    }
    .text_red, .severity-High {
        color: #CE1616;
    }
    .text_orange, .severity-Medium {
        color: #e85b0f;
    }
    .text_yellow, .severity-Low {
        color: #efbe0b;
    }
    .text_green, .severity-None {
        color: #13A10E;
    }
    .log-entry {
        margin-bottom: 8px;
    }
    .box {
        background: #080808;
        border: 1px solid #272727;
        border-radius: 8px;
        width: 500px;
        padding: 16px;
    }
    .box_inner {
        background: #080808;
        border: 1px solid #272727;
        border-radius: 4px;
        width: calc(100% - 32px);
        padding: 16px;
    }
    input, textarea {
        display: block;
        background: #080808;
        width: calc(100% - 16px);
        color: #eaeaea;
        border: 1px solid #272727;
        font-family: Rethink Sans, sans-serif;
        border-radius: 4px;
        padding: 8px;
        outline: none;
        resize: none;
        height: 80px;
    }
    mark {
        background: #5a4600;
        color: #eaeaea;
        border-radius: 2px;
        padding: 1px 4px;
    }
    .info {
        margin-top: 16px;
    }
</style>
</head>
<body>

<div class="scale-wrapper">
    <div class="box" style="font-size: 14px; text-align: center;">
        <b>AutoMod API</b><br>
        <div style="font-size: 12px; margin-top: 4px;"><a style="color: #eaeaea;" href="https://api.avatarka.ge/v1/automod">https://api.avatarka.ge/v1/automod</a></div><br>
        <pre style="background: #1e1e1e; color: #eaeaea; padding: 8px; border-radius: 6px; font-size: 14px; overflow-x: auto; position: relative;top: -10px; margin: 0px;"><code><a style="color: #eaeaea99; text-decoration: none;" href="https://www.npmjs.com/package/@avatarkage/automod">npm i @avatarkage/automod</a></code></pre>
        <textarea id="inputBox" placeholder="Type something..." autocomplete="off"></textarea>
        <div id="output" class="info"></div>
    </div>
</div>

<script>
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî INFO ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// This is the AutoMod API script. It operates by removing common
// non-alphanumeric characters then using an advanced obfuscation
// map to turn the special characters back into alphanumeric 
// characters. Using special formatting rules within the filters
// blacklists and whitelists, they are converted into a javascript
// regex which attempts to match a word within the sent text. It
// even uses an additional space-based regex to maintain authentic
// spaces but block bypassing ones.


// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî CONTRIBUTORS ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Lead Developer: 
// - AvatarKage (https://avatarkage.com)


// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî FILTERS CONFIGURATION ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Creates a global object then assigns the filters to it. To
// create your own filter, either add a new one below or anywhere
// else within your code before the calling of "AutoMod("text")".
//
// FILTER TEMPLATE AND RULES BELOW; UNCOMMENT TEMPLATE TO USE
//
// - "*YOUR_WORD" Makes the word catch anything before it from the last space
// - "YOUR_WORD*" Makes the word catch anything after it until the next space
// - "*YOUR_WORD*" Makes the word catch anything before and after it from the last space to the next space
// - "(?YOUR_CHARACTER)" Makes an optional statement where the letter forms a match whether inputted or not
// - "(YOUR_CHARACTER|YOUR_CHARACTER)" Makes a or statement where either letter are a match
// - "(?YOUR_CHARACTER|YOUR_CHARACTER)" Makes an optional or statement where either LETTER form a match whether inputted or not
// - "r:YOUR_REGEX" Enables the use of native JavaScript regex for this specific word entry; not compatible with the above rules
//
// automod.filters.YOUR_FILTER_ID = {
//     name: "", // How the filter will be recognized and friendly identified
//     group: "", // Useful for taking the same type of action or sending notifications for similar filters
//     severity: "", // "none", "low", "medium", "high", "critical"; same as the group comment
//     blacklist: [], // These words will be blocked when matched; refer to the rules guide
//     whitelist: [], // These words will be allowed and will override the blacklist when matched; refer to the rules guide
//     message: "", // The return warning to the user who attempted breach
//     bypass: false, // When true, the filter will be locally disabled via requests; eg: automod.filters.YOUR_FILTER_ID.bypass = (req.permissions == 8)
//     active: true // When false, the filter will be globally disabled
// };
//
// Note: You can edit any part of your or pre-defined filters anywhere using the following lines of code:
//
// - automod.filters.YOUR_FILTER_ID.KEY = ""; KEY is one of the following: "name", "group", "severity", "message", "bypass", "active"
// - automod.filters.YOUR_FILTER_ID.blacklist.push("YOUR_WORD"); Push a new word into the blacklist or whitelist
// - automod.filters.YOUR_FILTER_ID.blacklist =
//       automod.filters.YOUR_FILTER_ID.blacklist.filter(word => word !== "YOUR_WORD"); Remove an existing word from the blacklist or whitelist

// Creates the global object
var automod = {
    filters: {}
};

// Assigns the default discriminatory filter
automod.filters.discriminatory = 
    {
        name: "Discriminatory",
        group: "Unsafe Expressions",
        severity: "high",
        blacklist: ["*(ü•∑|üÜñ)*", "(?g)ga", "*n(i|e)g(a|g|h)(h|r|e|a)(?a|r)(?rs|s)*", "ig(?g)(r|e|a)(?a)(?rs|r|s)", "neg(?g)a(?r)(?s)", "n(?e|i|g)(e|g|h)(a|h|r)(?h)",
            "ng", "nig(?g|e)(?r)(?s)", "ngg(?e)(?r)", "*f(a|g)(o|g)*", "*ret(a|u)r*", "(ret|tard|turd)(?a|r)(?a|r)(?e)(?d)(?s|es|ies)",
            "coon(?s)", "*kike*", "yid(?s)", "*chink*", "ching(?s)", "*gook*", "*slopehead*", "jap(?s)",
            "*china(? )(wo)m(a|e)n*", "*coolie*", "*sambo*", "*tar(? )baby*", "*jemima(?s)*", "*mamm(?y|ies|s)*",
            "*pick(? )aninn(?y|ies|s)*", "*gay(? )lord(?s)*", "*dyke*", "*she(? )male*", "*trann(?y|ies|s)*",
            "*transvestite*", "*cripple*", "*white(? )power*", "n(? )word(?s)", "r(? )word(?s)", "cong(?s)",
            "*siss(?y|ies|s)*", "hard(?s)r", "*kanker(?s)*", "*lesbo(?s)*", "chong(?s)", "*cotton(? )picker*", "tor(i|ie|ies|y)(?s)",
            "(ninja|ng)(? )(emot|emoj|emote|emotion|emoji)", "mong(?g)(?er|ing)(?s)"
        ],
        whitelist: [],
        message: "Your message contains discriminatory language. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }

// Assigns the default sexually explicit filter
automod.filters.sexual = 
    {
        name: "Sexually Explicit",
        group: "Unsafe Expressions",
        severity: "high",
        blacklist: ["*(üçÜ|üçå|üçë|üçá)*", "*(1|2|one|two)(? )cup(?s)(? )(1|2|one|two)(? )(boy|girl|man|woman|guy|gal|dude|chick)*",
            "*(1|2|one|two)(? )(boy|girl|man|woman|guy|gal|dude|chick)(?s)(? )(1|2|one|two)(? )cup*", "*(1|2|one|two)(? )c(?s)(? )(1|2|one|two)(? )g*",
            "*(1|2|one|two)(? )g(?s)(? )(1|2|one|two)(? )c*", "anal(?s)", "anus(?es)", "ass(?es)", "*philia*", "*alabama(? )hot(? )pocket*",
            "*alaskan(? )pipeline*", "*anilingus*", "*erotic*", "*b(a|e)b(y|e)(? )(land|batter|beater|juice|water|liquid)*",
            "*(ball)(?s)(? )(gag|gravy|kick|lick|sack|suck)(?ing|er)*", "ba«Ås", "bang", "*bareback*", "*barely(? )legal*", "naked", 
            "nud(e|it|iti)(?i|s|ie|ies|y)(?i|t|e|y)(?s|y)(?s|ie|ies)",  "bbw", "*bdsm*", "*big(? )knocker*", "bimb(?s)", "*bird(? )lock*", 
            "*(action|blonde|brunette)(? )(?on)(? )(action|blonde|brunette)*", "*blow(? )(?your)(? )(job|load)*", "*blue(? )waffle*", "*blumpkin*", 
            "*bondag*", "*boner*", "*b(oo|·Äö|Íùè|Íöô|·Äë)b*", "*b(oo|Íöô|·Äö|Íùè|·Äë)ty*", "breast(?s)", "*(golden|yellow|brown)(? )shower*", "*bukkake*", "*bullet vibe*",
            "*busty*", "*butt*", "*(cam|camera)(? )(boy|girl|man|woman|guy|gal|dude|chick)(?s)*", "*camel(? )toe*", "*carpet(? )muncher*", 
            "*chocolate(? )rose*", "*circle(? )jerk*", "*clit*", "*clover(? )clamp*", "*cluster(? )fuck*", "*coprolagnia*", 
            "*corn(? )hole*", "*cream(? )pie*", "*cunnilingus*", "*deep(? )throat*", "*dildo*", "*dirty(? )sanchez*", "*dog(?g|i|y)(?y|i|e|ie)(?s)(? )style*", 
            "*dolcett*", "*dominatrix*", "*dommes*", "*double(? )dong*", "*double(? )penetration*", "*dp(? )action*", "*dry(? )hump*", "*dvda*", 
            "*ejaculation*", "erect*", "*eroti*", "*fellatio*", "*feltch*", "*squirting*", "*f(e|r)mbo(y|i)*", "*femdom*", "*fetish*", "*figging*", 
            "*fingerbang*", "*fingered*", "*fingeri*", "*fleshlight*", "*(foot|hand)(? )job*", "*(3|4|5|6|7|8|9|three|tre|thre|thee|tree|four|five|six|seven|sevn|svn|eight|nine)some*",
            "*frotting*", "*fudge(? )packer*", "*fudgepacker*", "*futanari*", "*g(? )spot*", "*genitals*", "*cock*",
            "*(boy|girl|man|woman|guy|gal|dude|chick)(?s)(? )on(? )(top|bottom)*", "*(boy|girl|man|woman|guy|gal|dude|chick)(?s)(? )gone(? )wild*", "*goatse*",
            "*gokkun*", "*goo(? )girl*", "*or(?e)gasm*", "*grope*", "*(?e)(? )sex*", "guro", 
            "*henta*", "*hooker*", "*h(?o)rn(i|y)*", "*hot(? )(carl|boy|girl|man|woman|guy|gal|dude|chick)*", "humpin(?g)", "*incest*", "*intercourse*", 
            "*j(ac|er)(?k)(?in|ing)(? )off*", "*j(ac|er)(?k)(? )mate*", "*jail(? )bait*", "jelly(? )donut", "*jerk*", "*jizz*", "*juggs*", "*kink*",
            "*leather(? )(straight|restraint)(? )jacket*", "*lemon(? )party*", "*lewd*", "*loli(?t|a|ta)*", "*love(? )making*", "*lust*",
            "cum(?m|in)(?in|ing|ed)(?s)", "*puss(y|ies)*", "*mastu*", "*menage(? )a(? )trois*", "*(m|d|f)ilf*", "*missionary*", "*(mound|venus)(? )of(? )(mound|venus)*",
            "*muff(? )div(?er|ing)*", "(?deeez|deez|dez|dz)(? )nut(?s)", "nipp(el|le)(?s)", "*nymphomania*", "*omorashi*", "*only(? )fan*",
            "org(y|ies)", "*phile*", "*peg(?g|s)(?ing|s)*", "*pek(? )pek*", "*pleasure(? )chest*", "*poop(? )chute*", "*po(?u)rn*", 
            "*prince(? )albert(? )piercing*", "*prosti*", "*pubes*", "*public(? )hair*", "*punany*", "*que(a|e)f*", "*rim(? )job*", 
            "*rimm(ed|ing)*", "*ros(e|y)(? )(toy|palm)*", "*r(?ule)(? )34*", "*rusty(? )trombone*", "s(&|and)m(?s)", 
            "*sadism*", "*scat*", "*schlong*", "*scissor(ing|ed)*", "semen(?s)", "*shave(?d)(? )beaver*", "*shibari*", "*shota*", "*shrimp(ed|ing)*", "*skeet*", 
            "*smash*", "*s(l|m)ut*", "*snowballin*", "*sodom(y|ize)*", "*spread(? )legs*", "*spunk*", "*strap(? )(on|pad)(?o)*",
            "*strip*", "*swinger*", "*tainted(? )love*", "*taste(? )my(? )teabag*", 
            "*tea(? )bagging*", "*tight(? )white*", "*tongue(? )in*", "*topless*", "*tribadism*", "*tub(? )(boy|girl|man|woman|guy|gal|dude|chick)*",
            "*tushy*", "*up(? )skirt*", "*urethra*", "*vagina*", "*viagra*", "*vibrator*", "*violet(? )wand*", "*voy(e|u)(e|u)r*", 
            "*vulva*", "*wank*", "*wet(? )dream*", "*wrapping(? )(boy|girl|man|woman|guy|gal|dude|chick)*", "*wrinkled(? )starfish*", "xxx",
            "*yaoi*", "*yarichin*", "ybc", "*yuri*", "*zoophi*", "*c(n|u|v)(n|u)t*", "*thot*", "*darkie*", "*whor(?e)*", "ho(?e)(?s)","*honkey*", "*jig(g|a)(?g|a)*",
            "*goon*", "*(father|mother)(? )f*", "*tosser*", "*twat*", "(go|to)(? )fuck", "(eat|suck)(? )(ass|butt)", "*sybau*",
            "*twink*", "*molest*", "*hose(? )mad*", "c(o|u)m(?s|shot)(?s)", "*fmby*", "*ambatukam*", "*ÿπÿ®ŸäÿØ*", "smd(?s)", 
            "*touch(? )you*", "fap(?p)(?ing|ed)(?s)", "ph", "*kurwa*", "*hot(? )18*", "*hot(? )(teen|10|ten)*", "*t3(?3)n*",
            "*honker(?s)*", "*ti(t|d)(?d)(?y)(?s)*", "*submissive*", "*fucker*", "*seduce*", 
            "*sle(pt|ep|eping)(? )with*", "*p(e|d)(do|file)*", "ped", "*f(?u)(?c)k(? )of(?f)*", 
            "*sausag*", "sek(?s)", "*wanna(?s)have(?s)(6|six)*", "*want(?s)(?to)(?s)have(?s)(6|six)*", 
            "*(see|sea)(?s)you(?s)(4|four|for|fr)(?s)(6|six)*",
            "*penile*", "*grape(?s|ed)(you|him|them|her)*", "(his|my|your)(?s)(d|c|k)", "*ngentott*", "v(?a|er)gin(?s)", "*penetration*", 
            "*anilingus*", "*bellend*", "prn, *eggplant(? )(emot|emoj|emote|emotion|emoji)*", "*banana(? )(emot|emoj|emote|emotion|emoji)*", "*peach(? )(emot|emoj|emote|emotion|emoji)*", "*grape(? )(emot|emoj|emote|emotion|emoji)*",
            "*foreskin*", "*slave*", "*moan*", "*pant(y|ies)*", "kbs", "*chesh*", "h(? )anime",
            "cox(?x), *gyat(?t)*", "*uterus*", "*asswipes*", "*twin(?u)k*", 
            "(you|youre|he|she|they)(? )(?is|are)(? )(?a)(? )knob", "*genita*", "*wel(? )cu(?m)*", "*feet(? )pic*", "*condom*", "*dadd(y|ie)*", 
            "sma(?s)", "dih(?h)", "*mfker*", "f(?u)(?c)k(? )(me|you|him|her|them|us|all)", "*penis*", "*dick*", "*cock*", "ra(?y)pe"
        ],
        whitelist: ["naked(? )eye", "breast(?s)(? )cancer(?s)", "sexualit(y|ies)", "lolipop(?s)"],
        message: "Your message contains sexually explicit language. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }

// Assigns the default regional filter
automod.filters.regional = 
    {
        name: "Regional",
        group: "Unsafe Expressions",
        severity: "medium",
        blacklist: [
            "*qaeda*", "*isis*", "*hamas*", "*taliban*", "*boko(? )haram*", "*al(? )shabaab*", "*(osama|laden)*", "*khalifa*", "*jihad*", 
            "*sharia*", "*caliphate*", "*nambla*", "*martyrdom*", "*hitler*", "*mussolini*", "*naz(i|y)*", "*fascis(m|t)*", "kkk", "*‚ò≠*", 
            "*Âçç*", "*Âçê*", "*paki*", "jap(?s)", "*g(? )word*", "*isr(ea|ae)l*", "*palest*", "*gaza*", "*hamas*", "*hezbollah*", "*ukrain*",
            "*russi*", "*donbas*", "*putin*", "*crimea*", "*taiwan*", "*tibet*", "*hong(? )kong*", "*south(? )china(? )sea*", "*kurd*", 
            "*pkk*", "*ypg*", "*biden*", "*joe(? )biten*", "*trump*", "maga", "*democ*", "*repub*", "*conservative*", "*liberal*", "bnp", 
            "*antifa*", "*proud(? )boys*", "*marxist*", "*communist*", "*brexit*", "*alt(? )right*", "*alt(? )left*", "*christ*",
            "*god*", "*jesus*", "*islam*", "*muslim*", "*allah*", "*yahweh*", "*adonai*", "*jew*", "*jewish*", "*hindu*", "*buddh*", "*atheist*",
            "*religion*", "*blasphemy*", "*prophet*", "(9 11|9/11)", "*twin(? )towers*", "*pearl(? )harbor*", "*tiananmen*", "*genocide*", "*holocaust*", "*shoah*",
            "*gulag*", "*nkvd*", "*(atomic|nuclear)*", "doge"
        ],
        whitelist: ["doge(? )(meme|dog)"],
        message: "Your message contains regional and/or controversial language. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }

// Assigns the default profanity filter
automod.filters.profanity = 
    {
        name: "Profanity",
        group: "Unsafe Expressions",
        severity: "low",
        blacklist: [
            "*üñï*", "*middle(? )finger*", "*b(?i)(?a)(tc| ®)h*", "*ar(?r)se(? )hole*", "*as(?s)(? )hole*", 
            "*basta(?r)(?d)*", "*b(o|u)l(?l)(? )lock*", "*stfu*", "*piss*", "*dumbas(?s)*", "*shit*",
            "*you(?r)(?e)(? )(?a)(? )birch*", "*bish*", "*fu(?c)(c|k|w|u)*"
        ],
        whitelist: [],
        message: "Your message contains profanital language. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }

// Assigns the default profanity abbreviations filter
automod.filters.abbreviations = 
    {
        name: "Profanity Abbreviations",
        group: "Unsafe Expressions",
        severity: "low",
        blacklist: [
            "fml", "mf", "(?w)tf", "*my(? )(god|lord)*", "o(m|n)(?f)(g|l)", "ist(g|l)",
            "lm(?f)(a|b)o", "*ü§¨*", "*(‚õ±Ô∏è|üèñÔ∏è)*", "(swear|beach|swears|swearing)(? )(emot|emoj|emote|emotion|emoji)", "*f****", "*s****",
            "(f|s|b)(?)(word)(?s)", "swear(? )(?to)(? )(god|lord)(?s)", "ahh", "*f(?u)(c|k|w|u)*", "(69|420)", "d(a|e)(m|n)(m|n)"
        ],
        whitelist: [],
        message: "Your message contains profanital language. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }

// Assigns the default blockchain filter
automod.filters.blockchain = 
    {
        name: "Blockchain",
        group: "Security Concern",
        severity: "medium",
        blacklist: [
            "*bitcoin*", "btc", "*ethereum*", "eth", "*binance*", "bnb", "*coinbase*", "*crypto*", "*nft*", "*blockchain*", 
            "*web(? )(3|three|thre|thee|tree|tre)*", "*metamask*", "*trustwallet*", "*solana*", "sol", "xrp", "ripple", "*cardano*", "ada",
            "*litecoin*", "ltc", "*dogecoin*", "matic", "*opensea*", "*rarible*", "defi", "*altcoin*", "*yield(? )farming*", "*chainlink*", 
            "*arbitrum*", "*zkrollup*", "*binance(? )smart(? )chain*", "bsc", "*avax*", "trx", "*uniswap*", "*sushiswap*", "*pancakeswap*", 
            "*trezor*", "*nano(? )ledger*", "*hardware(? )wallet*"
        ],
        whitelist: [],
        message: "Your message contains blockchain keywords. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }

// Assigns the default illegal filter
automod.filters.illegal = 
    {
        name: "Illegal",
        group: "Security Concern",
        severity: "high",
        blacklist: [
            "*piratebay*", "*(1|one)(3|three|free|thre|tree)(3|three|free|thre|tree)(7|seven|sevn|svn)x*", 
            "*rarbg*", "*torrent*", "*yts*", "*yify*", "*eztv*", "*fitgirl*", "*igg(? )game*", "*skidrow*", 
            "*reloaded*", "*cpy*", "*razor1911*", "*crackwatch*", "*oceanofgame*", "*steamunlock*", "*gamecopyworld*", "*megagame*", 
            "*myabandonware*", "*apkpure*", "*apkmirror*", "*apkdl*", "*mob(? )org*", "*blackbox(? )repack*", "*dodi(? )repack*", "*nexusmod*", 
            "*zooqle*", "*bitlord*", "*torlock*", "*torrend*", "*fmovie*", "*putlocker*", "*soap(2|two)day*", "*(1|one)(2|two)(3|three|free|thre|tree)movie*",
            "*yesmovie*", "*watchserie*", "*gomovie*", "*animeultima*", "*kissanime*", "*(9|nine)anime*", "*aniwatch*", "*watchcartoononline*", 
            "*watchserieshd*", "*dramacool*", "*bolly(4|four|for)u*", "*filmyzilla*", "*movierulz*", "*tamilrocker*", "*mkvcage*", "*hdpopcorn*", 
            "*movie(4|four)k*", "*moviesjoy*", "*popcorntime*", "*project(? )free(? )tv*", "*watchfree*", "*sockshare*", "*blackspigot*", 
            "*temu*", "*yiff*", "*rarbg*", "*repack(? )mechanic*", "*eztv*", "*pirat(?e)(?d)(?ing)(? )(?a)(? )game*", "*cocaine*", "heroi(?n)(?s)", "meth", 
            "*ecstasy*", "lsd", "*ketamine*", "*mdma*", "*fent(?an)*", "*crack*", "*opium*", "*opiates*", "pcp", "*cannabis*", "*marijuana*", 
            "weed", "*shroom*", "*psilocybin*", "*xanax*", "*xanny*", "*oxycodone*", "oxy", "*adderall*", "*purple(? )(drink|drank|drunk)*",
            "dabs", "*dark(web|net)*", "*hydroxybutyrate*", "hemp", "cbd", "*ayahuasca*", "*benzos*", 
            "*(do|did|grow|sell|sold|on|own)(?ing|ed)(? )(?some)(? )(?thing|think)(? )(drug|drg|drig|dgs|illegal)*", "*tax(? )evasion*", "*tax(? )bail*", 
            "*shoplift*", "*doxx*", "(drug|drg|drig|dgs)(?s)", "have(? )(?my|self|him|his|her|their|them|she|he|you|your|youre|youre|me|others|someone|anyone|everybody|all)(?s)(? )(ip)",
            "*(sold|sell|buy|leak|steal|stole|bought|hack)(?ing|ed)(? )(my|self|him|his|her|their|them|she|he|you|your|youre|youre|me|others|someone|anyone|everybody|all|ip|dm|message|email|pm|game|account|film|stuff)*"
        ],
        whitelist: ["mushroom"],
        message: "Your message contains illegal keywords. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }

// Assigns the default physical harm filter
automod.filters.harm = 
    {
        name: "Physical Harm",
        group: "Security Concern",
        severity: "high",
        blacklist: [
            "*(eat|drink|drnk|dnk|drunk|swallow|swlo|swllo|swllw|swllow|swollow)(?s|ing|ed)(? )(bleach|blech|blach|chem|poi)*",
            "*(want|wnt|wih|wish|wsh)(?ed|ing)(? )(i|me)(? )(?am|to|was|will|were|is|are)(? )(die|di|ded|dea|death|deth|unali|dead)*", 
            "*(i|me)(? )(?am|to|was|will|were|is|are)(? )(want|wnt|wih|wish|wsh)(?ed|ing)(? )(die|di|ded|dea|death|deth|unali|dead)*", 
            "s(? )h", "*(self)(? )(?inflict)(?ed|ing|s)(? )(harm|injur|ijur|muti)*", "*overdos(?e)(?ing|ed)(? )on(? )(pill|alcohol|drug|drg)(?s)*",
            "*head(? )bang*", "*(die|di|kill|death|dea|deth|ded|unali)(? )(?this)(? )(today|soon|later|tommorrow|week|month|year)*",
            "*(pill|alcohol|drug|drg)(?s)(? )(abu|abo)*", "*sex(?ual)(? )(assault|attack|abuse|battery)*", "*murderer*", "*mutilation*", 
            "*starve(? )(myself|me|self)*", "*binge(? )(?and|&|nd)(? )purge*", "*suicid(e|al)*", "*tak(?ing|e)(?ing)(? )(my|me|self)(? )life*", 
            "*self(? )destructive*", "*should(? )(die|death|deth|ded|unali)*", "*gok(m|y|h)s*","*shootup*", "*slit*", "k(m|y|h)s",
            "*end(? )(my|self|him|his|her|their|them|she|he|you|your|youre|youre|me|others|someone|anyone|everybody|all)(? )(life)*",
            "*(kill|murder|burn|beat|punch|mrdr|pnch|kick|abuse|stab|shoot|hurt)(? )(my|self|him|his|her|their|them|she|he|you|your|youre|youre|me|others|someone|anyone|everybody|all)*",
        ],
        whitelist: [],
        message: `Your message contains physical harm expressions. Attempting to bypass may result in action taken against your account. Know that help is available: <a href="https://suicidepreventionlifeline.org">https://suicidepreventionlifeline.org/</a>`,
        bypass: false,
        active: true
    }

// Assigns the default promotion filter
automod.filters.promotion = 
    {
        name: "Promotion",
        group: "Security Concern",
        severity: "medium",
        blacklist: [
            "*craigslist*", "*ebay*", "*download*", "*earn(? )($|‚Ç¨|¬•|¬¢)*", "*earn(? )(money|moolah|cash|euro|yen|card|giftcard|credit|credi)(?y|ies|es)*", 
            "*get launch*", "*hedge(9|nine)(0|zero)*", "*join(? )my(? )(server|discord)*", "*limited(? )(?time)(? )offer*", "*steam(? )nitro*", 
            "*(free|fre)(? )r(o|u)b(o|u)x*", "*($|‚Ç¨|¬•|¬¢|money|moolah|cash|euro|yen|giftcard|card|credit|credi)(? )gift*", "*get(? )(rich|money|credit|credi|wealthy|$|‚Ç¨|¬•|¬¢|money|moolah|cash|euro|yen|giftcard|card|credit)(? )quick*",
            "*(free|fre)(? )(account|boost|cash|credit|credi|discord|tag|download|game|giftcard|film|giveaway|money|nitro|paypal|reward|money|moolah|cash|euro|yen|giftcard|card)*",
            "*(click|pm|dm|message|email)(? )(?me)(? )(?for)(?free|fre)(account|boost|cash|credit|credi|discord|tag|download|game|giftcard|film|giveaway|money|nitro|paypal|reward|money|moolah|cash|euro|yen|giftcard|card)*",
            "*(please|pls|plz)(? )(sub|subscribe|follow)*"
        ],
        whitelist: ["downloading", "downloaded"],
        message: "Your message contains promotion or scam attempt keywords. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }

// Assigns the default domains filter
automod.filters.domains = 
    {
        name: "Domains",
        group: "",
        severity: "low",
        blacklist: [
            "r:\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b",
            "r:[a-z0-9\\-]+(?:\\.[a-z]{2,})+"
        ],
        whitelist: [
            "avatarka(.ge|ge.com)",
        ],
        message: "Your message contains unauthorized links. Attempting to bypass may result in action taken against your account.",
        bypass: false,
        active: true
    }


// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî OBFUSCATION CONFIGURATION ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Creates the obfuscation object inside the global automod object
// then assigns the mappings to it. To create your own obfuscation 
// map or edit an existing one, either add a new one below or
// anywhere else within your code before  the calling of 
// "AutoMod("text")".
//
// Note: You can edit any part of your or pre-defined obfuscations anywhere using the following lines of code:
//
// - automod.obfuscation.YOUR_CHARACTER.push("YOUR_CHARACTER"); Push a new character into the map
// - automod.obfuscation.YOUR_CHARACTER =
//       automod.obfuscation.YOUR_CHARACTER.filter(character => character !== "YOUR_CHARACTER"); Remove an existing character from the map

// Creates the obfuscation object
automod.obfuscation = {};

// Assigns the obfuscation mapping each letter of the alphabet
automod.obfuscation.a = 
    [
        "a", "A", "4", "@", "√Å", "√Ä", "√Ç", "√Ñ", "√É", "√Ö", "ƒÄ", "ƒÇ", "ƒÑ", "Œ±", "Œî", "Œõ", "–î", "‚àÜ", "ùí∂", "ùîû", "ùïí", "ùñÜ", "ùò¢", "ùòº", "ùóÆ", "ùôñ", "ùöä", 
        "‚í∂", "‚ìê", "üÖê", "üÑ∞", "ùêö", "ùñ∫", "·µÉ", "‚Çê", "ùõÇ", "ùõº", "üá¶", "Ôº°", "ùì™", "ÍìÆ", "–∞", "·¥Ä"
    ];

automod.obfuscation.b =
    [
        "b", "B", "8", "√ü", "‡∏ø", "Œ≤", "–ë", "ùí∑", "ùîü", "ùïì", "ùñá", "ùò£", "ùòΩ", "ùóØ", "ùôó", "ùöã", "‚í∑", "‚ìë", "üÖë", "üÑ±", "ùêõ", "·µá", "ùõÉ", "ùõΩ", "üáß", "…Æ", 
        "‰πÉ", "‡∏ø", "ÔΩÇ", "êåÅ", "·ó∑", "·∫û", "‚Çø", " ô"
    ];

automod.obfuscation.c =
    [
        "c", "C", "¬¢", "¬©", "√ß", "ƒÜ", "ƒå", "ƒà", "ƒä", "œÇ", " ó", "–°", "êêï", "ùí∏", "ùî†", "ùïî", "ùñà", "ùò§", "ùòæ", "ùó∞", "ùôò", "ùöå", "‚í∏", "‚ìí", "üÖí", "üÑ≤", "ùêú", 
        "·∂ú", "üá®", "üá®", "Íìö", "ÔΩÉ", "·¥Ñ", "·ëï"
    ];

automod.obfuscation.d =
    [
        "d", "D", "√ê", "ƒé", "ƒê", "‘Ä", "‘Å", "‘É", "Œ¥", "»°", "ùíπ", "ùî°", "ùïï", "ùñâ", "ùò•", "ùòø", "ùó±", "ùôô", "ùöç", "‚íπ", "‚ìì", "üÖì", "üÑ≥", "ùêù", "·µà", "ùõÖ", 
        "üá©", "‚ÖÖ", "ÔΩÑ", "‚±≠", "·¥Ö", "…ñ"
    ];

automod.obfuscation.e =
    [
        "e", "E", "3", "‚Ç¨", "√©", "√®", "√™", "√´", "ƒì", "ƒó", "ƒô", "Œû", "Œ£", "∆ê", "ùëí", "ùî¢", "ùïñ", "ùñä", "ùò¶", "ùôÄ", "ùó≤", "ùôö", "ùöé", "‚í∫", "‚ìî", "üÖî", 
        "üÑ¥", "ùêû", "·µâ", "‚Çë", "üá™", "Ôº•", "ÔΩÖ", "Íì∞", "·¥á", "«ù", "–≠", "“Ω", "—ë", "–µ", "$"
    ];

automod.obfuscation.f =
    [
        "f", "F", "∆í", "“í", "‚Ç£", "ùíª", "ùî£", "ùïó", "ùñã", "ùòß", "ùôÅ", "ùó≥", "ùôõ", "ùöè", "‚íª", "‚ìï", "üÖï", "üÑµ", "ùêü", "·∂†", "üá´", "ÔΩÜ", "Íú∞", "·ñ¥"
    ];

automod.obfuscation.g =
    [
        "g", "G", "6", "9", "ƒù", "ƒü", "ƒ°", "ƒ£", "…¢", "«•", "‚Ç≤", "ùì∞", "ùî§", "ùïò", "ùñå", "ùò®", "ùôÇ", "ùó¥", "ùôú", "ùöê", "‚íº", "‚ìñ", "üÖñ", "üÑ∂", "ùê†", "·µç", 
        "üá¨", "‚ÖÅ", "∆ì", "…°", "Íìñ"
    ];

automod.obfuscation.h =
    [
        "h", "H", "ƒ•", "ƒß", "–Ω", "ƒ¶", "#", "ùíΩ", "ùî•", "ùïô", "ùñç", "ùò©", "ùôÉ", "ùóµ", "ùôù", "ùöë", "‚íΩ", "‚ìó", "üÖó", "üÑ∑", "ùê°", " ∞", "‚Çï", "üá≠", "ÔΩà", " ú", 
        "…•"
    ];

automod.obfuscation.i =
    [
        "i", "I", "1", "!", "√≠", "√¨", "√Æ", "√Ø", "ƒ´", "ƒØ", "Œπ", "–Ü", "¬°", "|", "«ê", "ùíæ", "ùî¶", "ùïö", "ùñé", "ùò™", "ùôÑ", "ùó∂", "ùôû", "ùöí", "‚íæ", "‚ìò", "üÖò", 
        "üÑ∏", "ùê¢", "·∂¶", "·µ¢", "üáÆ", "*", "ÔΩâ", "…™", "$", "«Ä"
    ];

automod.obfuscation.j =
    [
        "j", "J", "ƒµ", " ù", "—ò", "–à", "¬ø", "ŸÑ", "ŸÑ", " ≤", "…ü", "‡¶ú", "œ≥", "ùíø", "ùîß", "ùïõ", "ùñè", "ùó∑", "ùò´", "ùôü", "ùöì", "‚íø", "‚ìô", "üÖô", "üÑπ", "ùê£", " ≤", 
        "üáØ", "ÔΩä", "·¥ä"
    ];

automod.obfuscation.k =
    [
        "k", "K", "ƒ∏", "Œ∫", "ƒ∑", "ƒ∂", "‚±©", "“†", "–∫", "“õ", "“ü", "“†", "ùìÄ", "ùî®", "ùïú", "ùñê", "ùó∏", "ùò¨", "ùô†", "ùöî", "‚ìÄ", "‚ìö", "üÖö", "üÑ∫", "ùê§", "·µè", "‚Çñ", 
        "üá∞", "ÔΩã", "·¥ã", " û", "·è¶"
    ];

automod.obfuscation.l =
    [
        "l", "L", "1", "|", "¬£", "≈Ç", "ƒø", "ƒπ", "ƒª", "ƒΩ", "‚Öº", "‚à£", "ÿß", "ÿß", "‚Öº", " ü", "„É¨", "·èû", "„Åó", "ÿßŸÑ", "ùìÅ", "ùî©", "ùïù", "ùñë", "ùóπ", "ùò≠", "ùô°", 
        "ùöï", "‚ìÅ", "‚ìõ", "üÖõ", "üÑª", "ùê•", "À°", "‚Çó", "üá±", "ÔΩå", "«Å"
    ];

automod.obfuscation.m =
    [
        "m", "M", "‚Ç•", "–º", "·πÉ", "·πÅ", "œª", "–º", "·Éù", "‡πì", "ùìÇ", "ùî™", "ùïû", "ùñí", "ùòÆ", "ùôà", "ùó∫", "ùô¢", "ùöñ", "‚ìÇ", "‚ìú", "üÖú", "üÑº", "ùê¶", "·µê", 
        "‚Çò", "üá≤", "ÔΩç", "·ó∞", "Áà™", "·é∑", "·¥ç", "Œú", "…Ø"
    ];

automod.obfuscation.n =
    [
        "n", "N", "√±", "≈Ñ", "≈Ü", "≈à", "≈â", "Œ∑", "–ø", "Œ†", "’≤", "‡∏†", "‡∏Å", "’º", "’º", "ùìÉ", "ùî´", "ùïü", "ùñì", "ùóª", "ùòØ", "ùô£", "ùöó", "‚ìù", "‚ìÉ", "üÑΩ", 
        "üÖù", "ùêß", "‚Åø", "‚Çô", "’º", "üá≥", "ÔΩé", "«å", "–ò", "…¥", "Œù", "–∏", "Íì†"
    ];

automod.obfuscation.o =
    [
        "o", "O", "0", "¬∞", "√∏", "√µ", "√∂", "√¥", "√≥", "√≤", "≈ì", "≈ç", "Œò", "–§", "¬§", "‚óé", "œÉ", "ùì∏", "·Äù", "·Äù", "êê¨", "ùî¨", "ùï†", "ùñî", "ùò∞", "ùôä", 
        "ùóº", "ùô§", "ùöò", "‚ìÑ", "‚ìû", "üÖû", "üÑæ", "ùê®", "·µí", "‚Çí", "üá¥", "Íöô", "ÔΩè", "Íùè", "·Äö", "‡πê", "·¥è", "·Äë", "Íì≥"
    ];

automod.obfuscation.p =
    [
        "p", "P", "√æ", "œÅ", "—Ä", "“è", "‚Ç±", "¬∂", "‚Ñó", "‚Ñò", "◊ß", "’©", "ùìÖ", "ùî≠", "ùï°", "ùñï", "ùò±", "ùôã", "ùóΩ", "ùô•", "ùöô", "‚ìÖ", "‚ìü", "üÖü", "üÑø", 
        "ùê©", "·µñ", "‚Çö", "üáµ", "·¥ò"
    ];

automod.obfuscation.q =
    [
        "q", "Q", "9", "«´", "’¶", "‘õ", " †", "œÜ", "…ã", " †", "ùìÜ", "ùîÆ", "ùï¢", "ùññ", "ùò≤", "ùôå", "ùóæ", "ùô¶", "ùöö", "‚ìÜ", "‚ì†", "üÖ†", "üÖÄ", "ùê™", "üá∂"
    ];

automod.obfuscation.r =
    [
        "r", "R", "¬Æ", "≈ô", "≈ó", "–≥", "—ì", "“ë", "’ê", "–≥", "—è", "–Ø", "ùìá", "ùîØ", "ùï£", "ùñó", "ùò≥", "ùôç", "ùóø", "ùôß", "ùöõ", "‚ìá", "‚ì°", "üÖ°", "üÖÅ", 
        "ùê´", " ≥", "üá∑", "ÔΩí", " Ä"
    ];

automod.obfuscation.s =
    [
        "s", "S", "5", "$", "¬ß", "≈°", "≈õ", "»ô", "—ï", "Íú±", " Ç", "÷Ü", " É", "·îï", "‰∏Ç", "‡∏£", "≈ü", "ùìà", "ùî∞", "ùï§", "ùñò", "ùò¥", "ùôé", "ùòÄ", "ùö†", "‚ìà", 
        "‚ì¢", "üÖ¢", "üÖÇ", "ùê¨", "À¢", "‚Çõ", "üá∏", "ÔΩì", "·èï", "Íï∂"
    ];

automod.obfuscation.t =
    [
        "t", "T", "7", "+", "‚Ä†", "≈£", "≈ß", "—Ç", "‚ä§", "êäó", "êä£", "‚üô", "—Ç", "—Ç", "ùìâ", "ùî±", "ùï•", "ùñô", "ùòµ", "ùôè", "ùó≤", "ùô©", "ùöù", "‚ìâ", "‚ì£", 
        "üÖ£", "üÖÉ", "ùê≠", "·µó", "‚Çú", "üáπ", "ÔΩî", " ®", "·¥õ", " á"
    ];

automod.obfuscation.u =
    [
        "u", "U", "(", "_", ")", "|", "√º", "√ª", "√π", "√∫", "≈´", "≈≥", "¬µ", "—ü", "—Ü", "—ü", " â", "‡∏ô", "·àÅ", "ùìä", "ùî≤", "ùï¶", "ùñö", "ùò∂", "ùôê", 
        "ùó≤", "ùô™", "ùöû", "‚ìä", "‚ì§", "üÖ§", "üÖÑ", "ùêÆ", "·µò", "·µ§", "üá∫", "ÔΩï", "·∂∏", "·¥ú", "·ëå", "’Ω"
    ];

automod.obfuscation.v =
    [
        "v", "V", "‚àö", " å", "ŒΩ", "v", "‚±±", "—µ", "ùìã", "ùî≥", "ùïß", "◊ò", "ùñõ", "ùò∑", "ùôë", "ùó≤", "ùô´", "ùöü", "‚ìã", "‚ì•", "üÖ•", "üÖÖ", "ùêØ", "·µõ", "üáª", 
        " ã", "·¥†"
    ];

automod.obfuscation.w =
    [
        "w", "W", "œâ", "≈µ", "—à", "—â", "—°", "·∫Å", "·∫É", "·∫Ö", "‡∏¨", "ùìå", "ùî¥", "ùï®", "ùñú", "ùò∏", "ùôí", "ùó≤", "ùô¨", "ùö†", "‚ìå", "‚ì¶", "üÖ¶", "üÖÜ", 
        "ùê∞", " ∑", "üáº", "ÔΩó", "·¥°"
    ];

automod.obfuscation.x =
    [
        "x", "X", "√ó", "œá", "—Ö", "–∂", "ùìç", "◊ê", "ùîµ", "ùï©", "ùñù", "ùòπ", "ùôì", "ùó≤", "ùô≠", "ùö°", "‚ìç", "‚ìß", "üÖß", "üÖá", "ùê±", "À£", "‚Çì", "üáΩ", "ÔΩò", 
        "“≥"
    ];

automod.obfuscation.y =
    [
        "y", "Y", "¬•", "√Ω", "√ø", "≈∑", "—É", "“Æ", "“∞", "“Ø", "·Éß", "·Éß", "◊¢", "Œ≥", "ùìé", "ùî∂", "ùï™", "ùñû", "ùò∫", "ùôî", "ùó≤", "ùôÆ", "ùö¢", "‚ìé", "‚ì®", 
        "üÖ®", "üÖà", "ùê≤", " ∏", "üáæ", "‚òØ", "ÔΩô", " è", " é", "·é©"
    ];

automod.obfuscation.z =
    [
        "z", "Z", "2", "≈æ", "≈∫", "≈º", " ê", " ë", "∆∂", "‚Ñ§", "‰πô", "ùìè", "ùî∑", "ùï´", "ùñü", "ùòª", "ùôï", "ùó≤", "ùôØ", "ùö£", "‚ìè", "‚ì©", "üÖ©", "üÖâ", "ùê≥", 
        "·∂ª", "üáø", "·¥¢", "·¥¢"
    ];


// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî SEPERATOR CONFIGURATION ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Creates the separators object inside the global automod object
// then assigns the mapping to it. You cannot create your own
// separators map, but you can edit the existing one below before
// the calling of "AutoMod("text")".
//
// Note: You can edit any part of the pre-defined separators anywhere using the following lines of code:
//
// - automod.separators.push("YOUR_CHARACTER"); Push a new character into the map
// - automod.separators =
//       automod.separators.filter(character => character !== "YOUR_CHARACTER"); Remove an existing character from the map

// Creates the separators object and assigns the mapping
automod.separators = 
    [
        " ", "-", ".", "_", "*", "^", "~", "`", "=", "+", ",", "|", "/", "\\", "'", "\"", ":", ";", "(", ")", "[", "]", 
        "{", "}", "<", ">", "@", "#", "!", "$", "%", "?","\n", "\r", "\t", "\f", "\v", "\u00A0", "\u200B", "\u200C", 
        "\u200D", "\u2060", "\u180E", "\uFEFF", "\u2063", "\u200E", "\u200F", "\u202A", "\u202B", "\u202C", "\u202D", 
        "\u202E", "\u0000", "\u0001", "\u0002", "\u0003", "\u0004", "\u0005", "\u0006", "\u0007", "\u0008", "\u000B", 
        "\u000E", "\u000F", "\u0010", "\u0011", "\u0012", "\u0013", "\u0014", "\u0015", "\u0016", "\u0017", "\u0018", 
        "\u0019", "\u001A", "\u001B", "\u001C", "\u001D", "\u001E", "\u001F", "\u00AD", "\u034F", "\u061C", "\uFFF9", 
        "\uFFFA", "\uFFFB", "\uFFFC"
    ];


// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî MODULE FUNCTIONS ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Functions used across this script to power the module.

// Function to replace "automod.separators" characters within a word
automod.separatorsClear = function(text) {
    const separators = new Set(automod.separators);
    const segments = text.match(/\S+|\s+/g);

    return segments
        .map(segment => {
            if (segment.trim() === '') {
                // If muliple spaces, collapse multiple spaces into one
                return ' ';
            } else {
                // segment is a word: remove separators, lowercase
                return [...segment]
                    .filter(char => !separators.has(char))
                    .join('')
                    .toLowerCase();
            }
        })
        .join('');
};

// Function to replace "automod.obfuscation" characters within a word
automod.obfuscationClear = function(word) {
    const obfuscation = automod.obfuscation;

    // Replace all the obfuscated characters
    const output = [...word]
        .map(character => replace_obfuscated(character))
        .join('');

    return output.toLowerCase();

    // Replace the obfuscated character with base key
    function replace_obfuscated(character) {
        for (const [key, group] of Object.entries(obfuscation)) {
            if (group.includes(character)) return key;
        }
        return character;
    }
}

// Function to use custom word rules to create a valid regex
automod.regexCreate = function(rule) {
    if (rule.startsWith("r:")) {
        try {
            return new RegExp(rule.slice(2), "i");
        } catch {
            return null;
        }
    }

    let regex_string = rule;

    // Check wildcards on first and last characters
    const wildcard_start = regex_string.startsWith('*');
    const wildcard_end = regex_string.endsWith('*');

    // Remove the wildcard characters from start/end for processing
    if (wildcard_start) regex_string = regex_string.slice(1);
    if (wildcard_end) regex_string = regex_string.slice(0, -1);

    // Temporarily replace all word rules with placeholders to protect their positions
    regex_string = regex_string
      .replace(/\(\?/g, "___OPT_START___")
      .replace(/\)/g, "___OPT_END___")
      .replace(/\|/g, "___OR___")
      .replace(/\?/g, "___QUESTION___");

    // Escape all other regex special characters to treat them literally
    regex_string = regex_string.replace(/[-\/\\^$+.\[\]{}]/g, '\\$&');

    // Restore the word rules back to original characters
    regex_string = regex_string
      .replace(/___OPT_START___/g, "(?")
      .replace(/___OPT_END___/g, ")")
      .replace(/___OR___/g, "|")
      .replace(/___QUESTION___/g, "?");

    // Replace optional space token "(? )" with optional space " ?"
    regex_string = regex_string.replace(/\(\? \)/g, ' ?');
    // Convert optional single characters like "(?x)" to "x?"
    regex_string = regex_string.replace(/\(\?([a-zA-Z]+)\)/g, '($1)?');
    // Converts OR groups like "(a|b)" to regex group "(a|b)"
    regex_string = regex_string.replace(/\(([a-zA-Z])\|([a-zA-Z])\)/g, '($1|$2)');
    // Converts optional OR groups like "(?a|b)" to "(a|b)?"
    regex_string = regex_string.replace(/\(\?([a-zA-Z\|]+)\)/g, '($1)?');

    // Re-wrap the wildcards when applicable
    if (wildcard_start && wildcard_end) {
        regex_string = `.*${regex_string}.*`;
    } else if (wildcard_start) {
        regex_string = `.*${regex_string}`;
    } else if (wildcard_end) {
        regex_string = `${regex_string}.*`;
    } else {
        regex_string = `\\b${regex_string}\\b`;
    }

    try {
        return new RegExp(regex_string, "i");
    } catch {
        return null;
    }
}

// Function to use spaces to create a valid regex out of blacklisted words
automod.regexSpaceCreate = function(regex) {
    const pattern = regex.source;
    let result = '';
    let in_escape = false;
    let in_class = false;
    let in_group = false;

    for (let i = 0; i < pattern.length; i++) {
        const char = pattern[i];

        if (in_escape) {
            result += '\\' + char;
            in_escape = false;
            continue;
        }

        if (char === '\\') {
            in_escape = true;
            continue;
        }

        result += char;

        // Handle character classes like [a-z]
        if (char === '[') in_class = true;
        if (char === ']') in_class = false;

        // Handle groups like (a|b)
        if (char === '(') in_group = true;
        if (char === ')') in_group = false;

        const next = pattern[i + 1];

        // Avoid spacing inside groups, classes, or after quantifiers
        if (
            i < pattern.length - 1 &&
            !in_class &&
            !in_group &&
            !['*', '+', '?', '|', ')', '(', '{', '}'].includes(next) &&
            !['*', '+', '?', '|', '(', ')'].includes(char)
        ) {
            result += '\\s*';
        }
    }

    return new RegExp(result, regex.flags);
}

// Function to test if a word is blocked
automod.test = function(text) {
    const original_text = text;
    const text_formatted = automod.separatorsClear(automod.obfuscationClear(text));

    for (const filter of Object.values(automod.filters)) {
        if (!filter.active) continue;
        if (filter.bypass) continue;

        const whitelist = filter.whitelist || [];
        const blacklist = filter.blacklist || [];

        // Whitelist check
        for (const whitelist_pattern of whitelist) {
            const whitelist_regex = automod.regexCreate(whitelist_pattern);
            const test_text = (true || whitelist_pattern.startsWith("r:")) 
                ? original_text 
                : text_formatted;
            if (whitelist_regex?.test(test_text)) return { blocked: false };
        }

        // Blacklist check
        for (const black_pattern of blacklist) {
            const blacklist_regex = automod.regexCreate(black_pattern);
            let spaced_regex;

            try {
                spaced_regex = automod.regexSpaceCreate(blacklist_regex);
            } catch {
                spaced_regex = null;
            }

            const test_text = black_pattern.startsWith("r:") ? original_text : text_formatted;

            const match = 
                blacklist_regex?.exec(test_text) || 
                spaced_regex?.exec(test_text);

            if (match) {
                return {
                    name: filter.name,
                    group: filter.group,
                    severity: filter.severity,
                    message: filter.message,
                    matched: black_pattern,
                    flagged: match[0],
                    regex: (blacklist_regex?.toString() || ''),
                    regex_spaced: (spaced_regex?.toString() || ''),
                    blocked: true
                };
            }
        }
    }

    return { blocked: false };
};


  const input = document.getElementById('inputBox');
  const output = document.getElementById('output');

  async function checkText(text) {
    if (!text) {
      output.innerHTML = "";
      return;
    }

      const data = automod.test(text);

      if (data.blocked) {
        const flaggedUsername = "Username";
        const flaggedHandle = "@username";
        
        const matchedWord = data.flagged;
        const reason = {
          name: data.name,
          severity: data.severity,
          message: data.message
        };
        const matchedListType = data.group;

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function highlightFlaggedWord(text, flagged) {
            if (!flagged) return text;
            const escapedFlagged = escapeRegExp(flagged);
            // Replace all occurrences, case-insensitive
            return text.replace(new RegExp(`(${escapedFlagged})`, 'gi'), '<mark>$1</mark>');
        }

        output.innerHTML = `
            <div class="box_inner" style="position: relative;">
                <img src="logo.png" width="16px" style="position: absolute; top: 16px; right: 16px;">
                <div style="display: flex; margin-bottom: 16px;">
                    <div style="font-size: 16px; display: flex; align-items: center; text-align: left;">
                        <img width="32px" style="border-radius: 32px; margin-right: 8px;" src="pfp.png">
                        <div style="display: flex; flex-direction: column; line-height: 1.2;">
                            <span><b>${flaggedUsername}</b></span>
                            <span style="font-size: 12px; opacity: 0.65;">${flaggedHandle}</span>
                        </div>
                    </div>
                </div>
                <div style="display: flex; align-items: flex-start; font-size: 14px; margin-bottom: 16px; text-align: left;">
                    <span class="vr"></span><div style="flex: 1;">${highlightFlaggedWord(text, data.flagged)}</div>
                </div>
                <div style="font-size: 10px; text-align: left; opacity: 0.65;">
                    <b>Keyword: </b>${data.matched} ‚Ä¢ <b>Filter: </b>${reason.name} (${reason.severity} Priority) ‚Ä¢ <b>Type: </b>${matchedListType}
                    <br><b>Message: </b>${reason.message}
                </div>
            </div>
        `;
      } else {
        output.innerHTML = "";
      }
  }

  input.addEventListener('input', (e) => {
    checkText(e.target.value);
  });
</script>

</body>
</html>
